<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Signature V2 下的多渠道打包]]></title>
    <url>%2Fundefined%2FAndroid-Signature-V2.html</url>
    <content type="text"><![CDATA[相关背景Android7.0 引入一项新的应用签名方案 APK Signnature Scheme v2(以下简称v2),这种新机制使得 apk 的签名方式更加安全，默认情况下,Android Studio2.2 和 Gradle2.2会使用v2签名方案来签名apk。如果使用v2这套签名方案就使得之前用的美团点评多渠道打包方案没用了，当然，美团点评在此基础上推出了新的解决方案 Walle。 需求 客户端需要传一个 Channel 字段给服务器； 在发包时需要使用360加固或者其他的加固方式给 apk 加固； apk命名需要自定义； 批量打包； 解决方案使用 v1 的签名方案禁用掉 v2，使用 v1。打开模块级 build.gradle 文件，配置如下：1234567891011android&#123; signingConfigs&#123; release&#123; storeFile file("releasekey.keystore") storePassword "password" keyAlias "ReleaseKey" keyPassword "password" v2SigningEnabled false &#125; &#125;&#125; 使用 v2 的签名方案之前的美团点评的多渠道打包方案无效，我们使用新的解决方案 Walle。如果不使用加固方案的话，直接按照 Walle 的 readme 操作即可，但是使用加固方案后，只能先加固，后签名，在通过 Walle 对这个签名后的 apk 进行多渠道打包，具体操作如下： 先在项目中引用 Walle 在位于项目的根目录 build.gradle 文件中添加 Walle Gradle 插件的依赖 12345buildscript&#123; dependencies&#123; classpath 'com.meituan.android.walle:plugin:1.1.5' &#125;&#125; 并在模块级 build.gradle 文件中apply这个插件，并添加上用于读取渠道号的 AAR 12345apply plugin: 'walle' dependencies &#123; compile 'com.meituan.android.walle:library:1.1.5'&#125; 通过以下方式获取渠道信息，并上传给服务器 1234ChannelInfo channelInfo= WalleChannelReader.getChannelInfo(this.getApplicationContext());if (channelInfo != null) &#123; String channel = channelInfo.getChannel();&#125; 至此，在项目中的配置就算完成了，如果想插入一些额外的信息或者要对 Walle 进行更多的配置，请参考 Walle 的 readme。配置完成后，通过 assembleRelease 命令生成使用v2签名方式的 apk。 拿这个 apk 去加固生成未签名的加固包。之后使用python工具去批量打自定义名称的渠道包。 channel.txt：渠道信息 config.py：配置签名信息以及 Android sdk 路径。 12345678#Windows 下路径分割线请注意使用\\转义keystorePath = &quot;&quot;keyAlias = &quot;&quot;keystorePassword = &quot;&quot;keyPassword = &quot;&quot;#Android SDK buidtools path , please use above 25.0+sdkBuildToolPath = &quot;&quot; MultiChannelBuildTool.py：基本思路就是遍历放置在同文件夹内的 apk 文件(将生成的未签名的加固包放置此处)。使用 v2 签名该 apk，然后将签名成功的 apk 通过 Walle 的命令行工具写入渠道等信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#!/usr/bin/python # -*-coding:utf-8-*-import zipfileimport shutilimport osimport sysimport platformimport config# 获取脚本文件的当前路径def curFileDir(): # 获取脚本路径 path = sys.path[0] # 判断为脚本文件还是py2exe编译后的文件， # 如果是脚本文件，则返回的是脚本的目录， # 如果是编译后的文件，则返回的是编译后的文件路径 if os.path.isdir(path): return path elif os.path.isfile(path): return os.path.dirname(path)# 判断当前系统def isWindows(): sysstr = platform.system() if (&quot;Windows&quot; in sysstr): return 1 else: return 0# 兼容不同系统的路径分隔符def getBackslash(): if (isWindows() == 1): return &quot;\\&quot; else: return &quot;/&quot;# 获取当前目录中所有的apk源包src_apks = []# python3 : os.listdir()即可，这里使用兼容Python2的os.listdir(&apos;.&apos;)for file in os.listdir(&apos;.&apos;): if os.path.isfile(file): if &quot;.apk&quot; in file: src_apks.append(file)# 获取渠道列表channel_file = &apos;channel.txt&apos;f = open(channel_file)lines = f.readlines()f.close()# 当前脚本文件所在目录parentPath = curFileDir() + getBackslash()# configlibPath = parentPath + &quot;lib&quot; + getBackslash()buildToolsPath = config.sdkBuildToolPath + getBackslash()checkAndroidV2SignaturePath = libPath + &quot;CheckAndroidV2Signature.jar&quot;walleChannelWritterPath = libPath + &quot;walle-cli-all.jar&quot;keystorePath = config.keystorePathkeyAlias = config.keyAliaskeystorePassword = config.keystorePasswordkeyPassword = config.keyPasswordfor src_apk in src_apks: # 原包路径 protectedSourceApkPath = parentPath + src_apkzipalignedApkPath = protectedSourceApkPath[0: -4] + &quot;_aligned.apk&quot;signedApkPath = zipalignedApkPath[0: -4] + &quot;_signed.apk&quot;# 对齐zipalignShell = buildToolsPath + &quot;zipalign -v 4 &quot; + protectedSourceApkPath + &quot; &quot; + zipalignedApkPathos.system(zipalignShell)# 签名signShell = buildToolsPath + &quot;apksigner sign --ks &quot; + keystorePath + &quot; --ks-key-alias &quot; + keyAlias + &quot; --ks-pass pass:&quot; + keystorePassword + &quot; --key-pass pass:&quot; + keyPassword + &quot; --out &quot; + signedApkPath + &quot; &quot; + zipalignedApkPathos.system(signShell)# 检查V2签名是否正确checkV2Shell = &quot;java -jar &quot; + checkAndroidV2SignaturePath + &quot; &quot; + signedApkPathos.system(checkV2Shell)# file name (with extension)src_apk_file_name = os.path.basename(src_apk)# 分割文件名与后缀temp_list = os.path.splitext(src_apk_file_name)# name without extensionsrc_apk_name = temp_list[0]# 后缀名&quot;.apk &quot;src_apk_extension = temp_list[1]# 创建生成目录,与文件名相关output_dir = src_apk_name + &apos;android_&apos; + &quot;1-&#123;channels&#125;&quot;.format(channels=len(lines)) + &apos;/&apos;# 目录不存在则创建if not os.path.exists(output_dir): os.mkdir(output_dir)# 遍历渠道号并创建对应渠道号的apk文件for line in lines: # 获取当前渠道号，因为从渠道文件中获得带有\n,所有strip一下 target_channel = line.strip() # 拼接对应渠道号的apk target_apk = output_dir + src_apk_name + src_apk_extension # 将签名后的apk拷贝建立新apk shutil.copy(signedApkPath, target_apk) writeChannelShell = &quot;java -jar &quot; + walleChannelWritterPath + &quot; put -c &quot; + target_channel + &quot; &quot; + target_apk os.system(writeChannelShell) 参考 Walle: https://github.com/Meituan-Dianping/walleJay-Goo: https://github.com/Jay-Goo/ProtectedApkResignerForWalle]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 hexo-theme-next 搭建博客（一）]]></title>
    <url>%2Fundefined%2Fbuild-blog-one.html</url>
    <content type="text"><![CDATA[本系列文章旨在教会你通过 next 主题搭建自己的 hexo 博客，跟着本系列完成后你的博客将会具备以下几个功能： 强调精于心，简于形的 next 主题，也可以很方便的定制和扩展； Hexo同时部署在 Coding 和 GitHub 上并使用 DNSPod 分流; LeanCloud 为文章添加阅读量统计功能，并在首页可以显示，不蒜子实现站内 UV PV 等统计； 百度统计； 站内搜索功能； RSS; 代码高亮，社交链接，打赏，动画等功能； 评论系统，可以匿名评论； …… 软件环境 Mac OS Git Node.js 本地站点搭建安装 Git Windows：下载安装 git 。 Download git Mac：使用 Homebrew，MacPorts 或下载 安装程序 安装 安装Node.js下载安装 Node.js。 Download Node.js,点击安装各个系统的版本，无脑的下一步即可完成安装。node.js 安装完成后，npm 也被安装完成。检测是否安装成功可以在终端输入命令查看 node.js 和 npm 的版本号。如下图所示： 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 输入以下命令查看 Hexo 的版本号：1$ hexo -v 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。123$ cd &lt;folder&gt;$ hexo init $ npm install 新建完成后，指定文件夹的目录如下：12345678.├── _config.yml # 网站的配置信息，在此称为站点配置文件，往后主题目录下也有相同命名的文件，称为主题配置文件├── package.json # 应用程序的信息├── scaffolds # 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。├── source # 资源文件夹是存放用户资源的地方。| ├── _drafts| └── _posts└── themes # 主题 文件夹。Hexo 会根据主题来生成静态页面。 执行以下命令，生成静态页面：1hexo generate 执行以下命令，启动服务：1hexo server 打开浏览器，输入http://localhost:4000/，即可在本地查看基于Hexo的默认主题的原型： 安装NexTHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。1theme: next 启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug，在启动之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 总结本章节主要介绍 Hexo 的本地站点的搭建以及使用 next 主题，下一章节主要介绍把博客部署在 Github page 和 Coding Page 上，并配置自己的域名访问。 Hexo 基本指令1234567$ hexo init # 新建一个网站$ hexo new [layout] &lt;title&gt; # 新建一篇文章$ hexo generate # 生成静态文件，部署时可以使用 hexo g -d$ hexo publish [layout] &lt;filename&gt; # 发表草稿$ hexo server # 启动服务器$ hexo deploy # 部署网站$ hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public) 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题 注意在配置文件中，冒号后面要留一个空格，要不然配置不生效 参考 hexo doc: https://hexo.io/zh-cn/docs/Never_yu’s Blog: https://neveryu.github.io/2016/09/03/hexo-next-one/]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[韦]]></title>
    <url>%2Fundefined%2FI.html</url>
    <content type="text"><![CDATA[I love you]]></content>
      <categories>
        <category>韦</category>
      </categories>
      <tags>
        <tag>-韦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱]]></title>
    <url>%2Fundefined%2FLove.html</url>
    <content type="text"><![CDATA[I love you]]></content>
      <categories>
        <category>爱</category>
      </categories>
      <tags>
        <tag>爱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[念]]></title>
    <url>%2Fundefined%2Fyou.html</url>
    <content type="text"><![CDATA[I love you]]></content>
      <categories>
        <category>念</category>
      </categories>
      <tags>
        <tag>念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I]]></title>
    <url>%2Fundefined%2F%E5%BF%B5.html</url>
    <content type="text"><![CDATA[I love you]]></content>
      <categories>
        <category>I</category>
      </categories>
      <tags>
        <tag>I</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Love]]></title>
    <url>%2Fundefined%2F%E7%88%B1.html</url>
    <content type="text"><![CDATA[I love you]]></content>
      <categories>
        <category>Love</category>
      </categories>
      <tags>
        <tag>-Love</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[you]]></title>
    <url>%2Fundefined%2F%E9%9F%A6.html</url>
    <content type="text"><![CDATA[I love you]]></content>
      <categories>
        <category>you</category>
      </categories>
      <tags>
        <tag>you</tag>
      </tags>
  </entry>
</search>
